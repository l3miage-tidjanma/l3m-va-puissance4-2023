export const dataTests = {"userMail":"alexandre.demeure@univ-grenoble-alpes.fr","version":66,"mutants":[{"op":"isValid","comment":"no 2 winners","code":"function anonymous(state\n) {\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n}","body":"\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"errors in reverse priority order","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"too much tokens <-> not turn of Pi","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"missing direction [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Mising direction [1, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >=4    --->   >4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >= 3","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"bad column number (-1)","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 > nbP2 /*+ 1*/","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP2 > nbP1 + 1","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"col >= 6","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 <-> nbP2","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"winner","comment":"nb > 4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, 1], ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"<= 6 ? \"DRAW\"","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"L.length === 6 ? \"DRAW\" ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"play","comment":"COL.length > 6","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column à virgule","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 0 || column > 6 || !Number.isInteger(column)","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 1 || column > 6 || !Number.isInteger(column) ","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P1","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P2","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"no turn change","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong token","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong column","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]}],"suites":[{"label":"Tests centrés sur isValid","id":"CLtMNpXwwUuXorvRyWtK","LtestIds":["9zz2MWHIDHnricejPYEG","zahqfNcLkAAp0Ory4Buc","vkPi4GpRL1LrmTRh3TSg","FyWP3BUb13yHI7CIQV8o","DUyhPA9v5Zvr9i6RDZ7h","BGOU33xCIRtZW6CB3EQP","FEnVgChU97fxlV4VYDe0","SxbbgMi2augHXTfK3T8C","qF0mYupPvMVSaYCW39aD","fu67DJlcPjyvOCri6UPg","31YAoX2NI8suoAfqEwKU","kkE7IxyRo472Ufj4LaNe","JjiR4uAJeN3QI8I8nIxE","hnNcFB6qkdi5WGnIb4uJ","BkokGCD2kKJzQPYlmMIs","WkozxK73wvLURpOAX1QF","fzcWNGNDdT5lk52YAAys","Nm2sEVS2ipHTajEGrctk","afAsUkY0VpkRK9KTWFQT"],"tests":[{"id":"9zz2MWHIDHnricejPYEG","comment":"P1 at start","expect":{"valid":true},"op":"isValid","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}]},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P2"}],"pass":true,"expect":{"reason":"not the turn of P2","valid":false},"id":"zahqfNcLkAAp0Ory4Buc","op":"isValid","result":{"valid":true},"comment":"P2 at start is invalid (not the turn of P2)"},{"id":"vkPi4GpRL1LrmTRh3TSg","params":[{"grid":[["P1","P2","P1","P2","P1","P2","P1"],[],[],[],[],[],[]],"turn":"P1"}],"op":"isValid","comment":"column 1 overload","expect":{"valid":false,"reason":"column 1 has too much tokens"}},{"pass":true,"expect":{"valid":false,"reason":"column 2 has too much tokens"},"op":"isValid","comment":"column 2 overload","result":{"reason":"column 1 has too much tokens","valid":false},"id":"FyWP3BUb13yHI7CIQV8o","params":[{"grid":[["P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P2"}]},{"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"result":{"reason":"column 2 has too much tokens","valid":false},"comment":"column 3 overload","id":"DUyhPA9v5Zvr9i6RDZ7h","pass":true,"expect":{"reason":"column 3 has too much tokens","valid":false},"op":"isValid"},{"result":{"reason":"column 3 has too much tokens","valid":false},"id":"BGOU33xCIRtZW6CB3EQP","pass":true,"expect":{"reason":"column 4 has too much tokens","valid":false},"comment":"column 4 overload","op":"isValid","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1","P2","P1","P2","P1"],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}]},{"op":"isValid","comment":"column 5 overload","pass":true,"id":"FEnVgChU97fxlV4VYDe0","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1","P2","P1","P2","P1"],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"expect":{"valid":false,"reason":"column 5 has too much tokens"},"result":{"valid":false,"reason":"column 4 has too much tokens"}},{"result":{"valid":false,"reason":"column 5 has too much tokens"},"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"expect":{"reason":"column 6 has too much tokens","valid":false},"pass":true,"op":"isValid","comment":"column 6 overload","id":"SxbbgMi2augHXTfK3T8C"},{"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2"],["P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"comment":"column 7 overload","pass":true,"op":"isValid","expect":{"reason":"column 7 has too much tokens","valid":false},"id":"qF0mYupPvMVSaYCW39aD","result":{"valid":false,"reason":"column 6 has too much tokens"}},{"id":"fu67DJlcPjyvOCri6UPg","op":"isValid","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"reason":"not the turn of P1","valid":false},"pass":true,"result":{"reason":"column 7 has too much tokens","valid":false},"comment":"Not the turn of P1"},{"expect":{"valid":false,"reason":"not the turn of P2"},"op":"isValid","result":{"reason":"There cannot be two winners","valid":false},"id":"31YAoX2NI8suoAfqEwKU","pass":false,"comment":"Not the turn of P2","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"result":{"reason":"not the turn of P2","valid":false},"pass":true,"id":"kkE7IxyRo472Ufj4LaNe","comment":"There cannot be 2 winners","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid","expect":{"valid":false,"reason":"There cannot be two winners"}},{"result":{"reason":"There cannot be two winners","valid":false},"id":"JjiR4uAJeN3QI8I8nIxE","expect":{"valid":false,"reason":"There cannot be two winners"},"pass":true,"op":"isValid","params":[{"grid":[[],["P1"],["P1","P1"],["P1","P1","P1","P2"],["P2","P2","P2","P1"],["P2","P2"],["P2"]],"turn":"P1"}],"comment":"There cannot be 2 winners (simple)"},{"result":{"valid":false,"reason":"There cannot be two winners"},"op":"isValid","id":"hnNcFB6qkdi5WGnIb4uJ","comment":"There cannot be 2 winners (simple 2 )","pass":true,"params":[{"grid":[["P2","P2"],["P1","P1"],["P1","P1","P2","P1"],["P1","P1","P1","P2","P1"],["P2","P1","P2"],["P2","P2"],["P2"]],"turn":"P2"}],"expect":{"valid":false,"reason":"There cannot be two winners"}},{"expect":{"valid":false,"reason":"There cannot be two winners"},"id":"BkokGCD2kKJzQPYlmMIs","comment":"no two winners (P2 first winner to be detected)","params":[{"turn":"P2","grid":[["P2"],["P2"],["P2"],["P2"],[],["P1"],["P1","P1","P1","P1"]]}],"op":"isValid"},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"op":"isValid","pass":true,"id":"WkozxK73wvLURpOAX1QF","result":{"exec":"success","returns":{"reason":"not the turn of P2","valid":false}},"expect":{"valid":false,"reason":"too much token for P1"},"comment":"Too much token for P1(P2 turn)"},{"id":"fzcWNGNDdT5lk52YAAys","pass":true,"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":{"exec":"success","returns":{"valid":false,"reason":"too much token for P1"}},"comment":"Too much token for P1(P1 turn)","expect":{"valid":false,"reason":"too much token for P1"},"op":"isValid"},{"expect":{"reason":"too much token for P2","valid":false},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid","id":"Nm2sEVS2ipHTajEGrctk","pass":true,"comment":"Too much token for P2(P1 turn)","result":{"exec":"success","returns":{"reason":"too much token for P1","valid":false}}},{"op":"isValid","expect":{"valid":false,"reason":"too much token for P2"},"comment":"Too much token for P2(P2 turn)","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"pass":true,"id":"afAsUkY0VpkRK9KTWFQT","result":{"returns":{"valid":false,"reason":"too much token for P2"},"exec":"success"}}]},{"LtestIds":["opCbwNLH5RawRxeVPJxj"],"id":"FOh3jlqLiCwXCrZssGls","label":"debug","tests":[{"id":"opCbwNLH5RawRxeVPJxj","op":"isValid","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}],"expect":{"valid":true},"comment":"test écrasement des résons d'invalidité"}]},{"label":"Tests centrés sur winner","LtestIds":["glLaSQXbmUmgBmp6r2Mm","syiCwg8OD3K1W9EF92t9","kW4LcQzWEq6X00x7HBO5","TKHBHQcld9qDMXYQPj7q","5FOBGLPXH8u8QIIX6G0V","beZzzcq4SOmoXL0oGu6w","LuHz9ZxboUtXSIWigbBK","8ujgWEKhQzj6zjuyXSrw","batpdJsyIgc43I7q6xJC","MZAKmTYHM7ilFnG8jvy7","HeBTqTGBhTX1mD2MS5Y0","b92FbWdyOFIRT9j4H1x4","3PLGMtvnuwx2XtWjdl82","wBa7XMsYYhuUE07uxMsj","pcVytVFoXLDk5eQDoaXy","tGMb50UQ2JRMiXRnZOgr","9yWW3X0eQ1MagqBZ0Kwj","s9tb4tbHC18IMnq8Qv1F","Vm2yyQtmdHg5XhKkrIo8","2EozqANDNIsWdZt0rx84"],"id":"Iokl5GpxtANX776ava1K","tests":[{"id":"glLaSQXbmUmgBmp6r2Mm","op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],[],[],[],[],[],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":true},"comment":"First and last column full, no winner yet"},{"comment":"no winner at beginning","expect":"no winner yet","id":"syiCwg8OD3K1W9EF92t9","op":"winner","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}]},{"expect":{"valid":true},"op":"isValid","pass":true,"comment":"valid full grid ","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"id":"kW4LcQzWEq6X00x7HBO5","result":{"valid":true}},{"result":{"valid":true},"expect":"DRAW","op":"winner","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"valid full grid DRAW","id":"TKHBHQcld9qDMXYQPj7q"},{"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"comment":"P1 win is valid (horizontal)","op":"isValid","pass":true,"result":"DRAW","id":"5FOBGLPXH8u8QIIX6G0V"},{"expect":"P1","id":"beZzzcq4SOmoXL0oGu6w","comment":"P1 win  (horizontal)","op":"winner","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"result":{"valid":true}},{"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":"P1","op":"winner","id":"LuHz9ZxboUtXSIWigbBK","comment":"P2 win  (horizontal)","expect":"P2"},{"result":"P2","pass":true,"comment":"P2 win is valid  (horizontal)","expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"id":"8ujgWEKhQzj6zjuyXSrw","op":"isValid"},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"id":"batpdJsyIgc43I7q6xJC","result":{"valid":true},"op":"isValid","expect":{"valid":true},"pass":true,"comment":"P2 win is valid  (North-East)"},{"expect":"P2","pass":true,"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"id":"MZAKmTYHM7ilFnG8jvy7","comment":"P2 win  (North-East)","op":"winner"},{"op":"isValid","id":"HeBTqTGBhTX1mD2MS5Y0","result":"P2","comment":"P1 win is valid (North-East)","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"pass":true,"expect":{"valid":true}},{"id":"b92FbWdyOFIRT9j4H1x4","comment":"P1 win (North-East)","pass":true,"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"expect":"P1","op":"winner"},{"comment":"P1 win (South-East)","result":"P1","op":"winner","expect":"P1","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"id":"3PLGMtvnuwx2XtWjdl82"},{"expect":{"valid":true},"id":"wBa7XMsYYhuUE07uxMsj","comment":"P1 win is valid (South-East)","op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"result":{"valid":true},"pass":true},{"op":"isValid","id":"pcVytVFoXLDk5eQDoaXy","pass":true,"result":{"valid":true},"comment":"P2 win is valid (South-East)","expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}]},{"comment":"P1 win is valid (Vertical)","id":"tGMb50UQ2JRMiXRnZOgr","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"expect":{"valid":true},"op":"isValid","result":{"valid":true},"pass":true},{"op":"winner","comment":"P1 win (Vertical)","result":{"valid":true},"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"id":"9yWW3X0eQ1MagqBZ0Kwj","expect":"P1"},{"op":"isValid","comment":"P2 win is valid (Vertical)","pass":true,"expect":{"valid":true},"id":"s9tb4tbHC18IMnq8Qv1F","result":"P1","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}]},{"id":"Vm2yyQtmdHg5XhKkrIo8","expect":"P2","op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"comment":"P2 win (Vertical)","pass":true,"result":{"valid":true}},{"expect":"P2","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"result":{"valid":true},"op":"winner","pass":true,"comment":"P2 win (South-East)","id":"2EozqANDNIsWdZt0rx84"}]},{"label":"Tests centrés sur play","LtestIds":["b4kZF25jBSAuBzFN2qXJ","qcfoC7J2Xuyco68urGt5","R2CYLCliEJ6NMzhwinXP","yChU1qBNQNgh6JQ6WvWH","iCqK3kWJzOMsJ2sc8T9h","Q27G8Ha2dR9bYTvUoL6M","ID1QEDyJelNSuQX31wsq","wrhW8AJ3bqGfIBraGO7E","wyjsQEs96yujowPxSvyK","phjLRjzsSpDMaFN9TPxm","QAU8unGFzPlAePNGcj7B","9Y6TAKJm1vlKbkfN5TcA","THzFebM3mnvxc8eWE62A","7sPqLgqlM5YuZmpT8o54"],"id":"vLSmQjtYL408m9TPGq5G","tests":[{"params":[{"grid":[["P1"],["P2"],[],[],[],[],[]],"turn":"P1"},4],"comment":"second coup sur 4","op":"play","expect":{"state":{"grid":[["P1"],["P2"],[],["P1"],[],[],[]],"turn":"P2"},"success":true},"id":"b4kZF25jBSAuBzFN2qXJ"},{"expect":{"state":{"grid":[["P1"],[],[],[],[],[],[]],"turn":"P2"},"success":true},"op":"play","id":"qcfoC7J2Xuyco68urGt5","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},1],"comment":"play at 1"},{"expect":{"success":false,"reason":"no such column"},"comment":"impossible to play at 2.1","id":"R2CYLCliEJ6NMzhwinXP","op":"play","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},2.1]},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},0],"op":"play","id":"yChU1qBNQNgh6JQ6WvWH","comment":"impossible to play at 0","expect":{"success":false,"reason":"no such column"}},{"op":"play","params":[{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1"]],"turn":"P2"},7],"expect":{"state":{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1","P2"]],"turn":"P1"},"success":true},"comment":"possible to play at 7","id":"iCqK3kWJzOMsJ2sc8T9h"},{"id":"Q27G8Ha2dR9bYTvUoL6M","expect":{"success":false,"reason":"no such column"},"op":"play","comment":"Impossible to play at 8","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},8]},{"pass":true,"op":"isValid","comment":"Full grid is valid","result":{"reason":"no such column","success":false},"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"id":"ID1QEDyJelNSuQX31wsq"},{"pass":true,"id":"wrhW8AJ3bqGfIBraGO7E","result":{"valid":true},"expect":"DRAW","comment":"Draw with full grid and player 1 turn","op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}]},{"comment":"Draw grid, cannot play at 1","result":"DRAW","pass":true,"op":"play","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},1],"id":"wyjsQEs96yujowPxSvyK","expect":{"reason":"column is full","success":false}},{"comment":"Draw grid, cannot play at 2","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},2],"expect":{"reason":"column is full","success":false},"id":"phjLRjzsSpDMaFN9TPxm","pass":true,"op":"play","result":{"success":false,"reason":"column is full"}},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},3],"pass":true,"id":"QAU8unGFzPlAePNGcj7B","op":"play","comment":"Draw grid, cannot play at 3","result":{"reason":"column is full","success":false},"expect":{"success":false,"reason":"column is full"}},{"result":{"reason":"column is full","success":false},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},5],"op":"play","id":"9Y6TAKJm1vlKbkfN5TcA","comment":"Draw grid, cannot play at 5","pass":true,"expect":{"success":false,"reason":"column is full"}},{"result":{"reason":"column is full","success":false},"comment":"Draw grid, cannot play at 6","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},6],"pass":true,"id":"THzFebM3mnvxc8eWE62A","op":"play","expect":{"success":false,"reason":"column is full"}},{"op":"play","pass":true,"expect":{"reason":"column is full","success":false},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},7],"id":"7sPqLgqlM5YuZmpT8o54","comment":"Draw grid, cannot play at 7","result":{"success":false,"reason":"column is full"}}]}],"canObserveString":"[   \"alexandre.demeure@univ-grenoble-alpes.fr\", \"sybille.caffiau@univ-grenoble-alpes.fr\", \"Adil-Massa.Adomo-Bitea@etu.univ-grenoble-alpes.fr\", \"Elhadj.Bah@etu.univ-grenoble-alpes.fr\", \"Ibrahima.Barry2@etu.univ-grenoble-alpes.fr\", \"Mariama.Barry@etu.univ-grenoble-alpes.fr\", \"Anas.Benabbou@etu.univ-grenoble-alpes.fr\", \"Ilian.Benaissa@etu.univ-grenoble-alpes.fr\", \"Sami.Bensaid@etu.univ-grenoble-alpes.fr\", \"Mustapha-Mahrez.Bouchelouche@etu.univ-grenoble-alpes.fr\", \"Walid.Bouhali@etu.univ-grenoble-alpes.fr\", \"Leo.Bouvier1@etu.univ-grenoble-alpes.fr\", \"Quentin.Bebin@etu.univ-grenoble-alpes.fr\", \"Kyllian.Charre@etu.univ-grenoble-alpes.fr\", \"Vincent.Chazeau@etu.univ-grenoble-alpes.fr\", \"Seynabou.Conde@etu.univ-grenoble-alpes.fr\", \"Levi.Cormier@etu.univ-grenoble-alpes.fr\", \"Samuel.Damessi@etu.univ-grenoble-alpes.fr\", \"Alex.Delagrange@etu.univ-grenoble-alpes.fr\", \"Oumou.Dembele@etu.univ-grenoble-alpes.fr\", \"Fatoumata.Diaby@etu.univ-grenoble-alpes.fr\", \"Aminata.Diagne@etu.univ-grenoble-alpes.fr\", \"Thierno.Diallo3@etu.univ-grenoble-alpes.fr\", \"Tien.Duong@etu.univ-grenoble-alpes.fr\", \"Anas.El-Bouchrifi@etu.univ-grenoble-alpes.fr\", \"Mouad.El-Kbabty@etu.univ-grenoble-alpes.fr\", \"Chaymae.Elkhou@etu.univ-grenoble-alpes.fr\", \"Khalil.Essouaid@etu.univ-grenoble-alpes.fr\", \"Abdelkader.Ezarouali@etu.univ-grenoble-alpes.fr\", \"Matias.Freund-Galeano@etu.univ-grenoble-alpes.fr\", \"Lucas.Giry@etu.univ-grenoble-alpes.fr\", \"Quentin.Grange@etu.univ-grenoble-alpes.fr\", \"Rayane.Guendouz@etu.univ-grenoble-alpes.fr\", \"Paul.Gueripel@etu.univ-grenoble-alpes.fr\", \"Jocelin.Heinen@etu.univ-grenoble-alpes.fr\", \"Floriane.Jandot@etu.univ-grenoble-alpes.fr\", \"Myriam.Khaddar@etu.univ-grenoble-alpes.fr\", \"Ibrahim-Goukouni.Khalil@etu.univ-grenoble-alpes.fr\", \"Zeinabou.Kone@etu.univ-grenoble-alpes.fr\", \"Hatim.Laghrissi@etu.univ-grenoble-alpes.fr\", \"Yasmine.Larbi@etu.univ-grenoble-alpes.fr\", \"Nour.Machmachi@etu.univ-grenoble-alpes.fr\", \"Salaheddin.Mesouak@etu.univ-grenoble-alpes.fr\", \"Souleymen.Ouchane@etu.univ-grenoble-alpes.fr\", \"Lyna.Oulahcene@etu.univ-grenoble-alpes.fr\", \"Willem.Papeau@etu.univ-grenoble-alpes.fr\", \"Theo.Patrac@etu.univ-grenoble-alpes.fr\", \"Timoty.Razafindrabe@etu.univ-grenoble-alpes.fr\", \"Bastien.Riado@etu.univ-grenoble-alpes.fr\", \"Ayman.Salouh@etu.univ-grenoble-alpes.fr\", \"Floreal.Sangenis@etu.univ-grenoble-alpes.fr\", \"Farah.Seifeddine@etu.univ-grenoble-alpes.fr\", \"Mariam.Sidibe@etu.univ-grenoble-alpes.fr\", \"Damien.Tornambe@etu.univ-grenoble-alpes.fr\", \"Julien.Turc@etu.univ-grenoble-alpes.fr\", \"Marie.Wyss@etu.univ-grenoble-alpes.fr\", \"Sicong.Xu@etu.univ-grenoble-alpes.fr\", \"Mohamad-Majd.Yagan@etu.univ-grenoble-alpes.fr\", \"Kokouvi.Zodjihoue@etu.univ-grenoble-alpes.fr\" ]","canObserve":"[   \"alexandre.demeure@univ-grenoble-alpes.fr\", \"sybille.caffiau@univ-grenoble-alpes.fr\", \"Adil-Massa.Adomo-Bitea@etu.univ-grenoble-alpes.fr\", \"Elhadj.Bah@etu.univ-grenoble-alpes.fr\", \"Ibrahima.Barry2@etu.univ-grenoble-alpes.fr\", \"Mariama.Barry@etu.univ-grenoble-alpes.fr\", \"Anas.Benabbou@etu.univ-grenoble-alpes.fr\", \"Ilian.Benaissa@etu.univ-grenoble-alpes.fr\", \"Sami.Bensaid@etu.univ-grenoble-alpes.fr\", \"Mustapha-Mahrez.Bouchelouche@etu.univ-grenoble-alpes.fr\", \"Walid.Bouhali@etu.univ-grenoble-alpes.fr\", \"Leo.Bouvier1@etu.univ-grenoble-alpes.fr\", \"Quentin.Bebin@etu.univ-grenoble-alpes.fr\", \"Kyllian.Charre@etu.univ-grenoble-alpes.fr\", \"Vincent.Chazeau@etu.univ-grenoble-alpes.fr\", \"Seynabou.Conde@etu.univ-grenoble-alpes.fr\", \"Levi.Cormier@etu.univ-grenoble-alpes.fr\", \"Samuel.Damessi@etu.univ-grenoble-alpes.fr\", \"Alex.Delagrange@etu.univ-grenoble-alpes.fr\", \"Oumou.Dembele@etu.univ-grenoble-alpes.fr\", \"Fatoumata.Diaby@etu.univ-grenoble-alpes.fr\", \"Aminata.Diagne@etu.univ-grenoble-alpes.fr\", \"Thierno.Diallo3@etu.univ-grenoble-alpes.fr\", \"Tien.Duong@etu.univ-grenoble-alpes.fr\", \"Anas.El-Bouchrifi@etu.univ-grenoble-alpes.fr\", \"Mouad.El-Kbabty@etu.univ-grenoble-alpes.fr\", \"Chaymae.Elkhou@etu.univ-grenoble-alpes.fr\", \"Khalil.Essouaid@etu.univ-grenoble-alpes.fr\", \"Abdelkader.Ezarouali@etu.univ-grenoble-alpes.fr\", \"Matias.Freund-Galeano@etu.univ-grenoble-alpes.fr\", \"Lucas.Giry@etu.univ-grenoble-alpes.fr\", \"Quentin.Grange@etu.univ-grenoble-alpes.fr\", \"Rayane.Guendouz@etu.univ-grenoble-alpes.fr\", \"Paul.Gueripel@etu.univ-grenoble-alpes.fr\", \"Jocelin.Heinen@etu.univ-grenoble-alpes.fr\", \"Floriane.Jandot@etu.univ-grenoble-alpes.fr\", \"Myriam.Khaddar@etu.univ-grenoble-alpes.fr\", \"Ibrahim-Goukouni.Khalil@etu.univ-grenoble-alpes.fr\", \"Zeinabou.Kone@etu.univ-grenoble-alpes.fr\", \"Hatim.Laghrissi@etu.univ-grenoble-alpes.fr\", \"Yasmine.Larbi@etu.univ-grenoble-alpes.fr\", \"Nour.Machmachi@etu.univ-grenoble-alpes.fr\", \"Salaheddin.Mesouak@etu.univ-grenoble-alpes.fr\", \"Souleymen.Ouchane@etu.univ-grenoble-alpes.fr\", \"Lyna.Oulahcene@etu.univ-grenoble-alpes.fr\", \"Willem.Papeau@etu.univ-grenoble-alpes.fr\", \"Theo.Patrac@etu.univ-grenoble-alpes.fr\", \"Timoty.Razafindrabe@etu.univ-grenoble-alpes.fr\", \"Bastien.Riado@etu.univ-grenoble-alpes.fr\", \"Ayman.Salouh@etu.univ-grenoble-alpes.fr\", \"Floreal.Sangenis@etu.univ-grenoble-alpes.fr\", \"Farah.Seifeddine@etu.univ-grenoble-alpes.fr\", \"Mariam.Sidibe@etu.univ-grenoble-alpes.fr\", \"Damien.Tornambe@etu.univ-grenoble-alpes.fr\", \"Julien.Turc@etu.univ-grenoble-alpes.fr\", \"Marie.Wyss@etu.univ-grenoble-alpes.fr\", \"Sicong.Xu@etu.univ-grenoble-alpes.fr\", \"Mohamad-Majd.Yagan@etu.univ-grenoble-alpes.fr\", \"Kokouvi.Zodjihoue@etu.univ-grenoble-alpes.fr\" ]","evals":[63,{"winner":[11,11],"isValid":[30,30],"play":[12,12]},{"winner":[7,7],"play":[9,9],"isValid":[14,14]}]}